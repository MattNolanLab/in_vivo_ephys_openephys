function [poss,frmap,xmap,ymap,spdmap,xchange] = ratemap(posx,posy,spkx,spky,binsize_override, pixel_ratio,min_dwell_dist, min_dwell_time, dt_pos, smooth, isShift)
% in this version, the place fields are generated by gaussian smoothed firing rate in each bin.
% the rate map implementation is based on Leutgeb et. al. Science, 2007, 315, 961-966
min_dwell = round(min_dwell_time / dt_pos);
% Generate empty position matrix
% WARNING: this assumes nice position data
% (i.e. no stray samples at edges)
smooth = smooth /100 * pixel_ratio;
xbinsize = binsize_override /100 * pixel_ratio;
ybinsize = xbinsize;
min_dwell_dist = min_dwell_dist / 100 * pixel_ratio;
if(isShift);
    minposx = min(posx);
    minposy = min(posy);    
    posx = posx - minposx + 0.0001; % set lowerleftmostpoint to 0,0
    posy = posy - minposy + 0.0001; % 0.0001 is to avoid bin 0 in 1st point
    spkx = spkx - minposx + 0.0001;
    spky = spky - minposy + 0.0001;
end
dx = max(posx);
dy = max(posy);
xbins = ceil(max(dx)/xbinsize);
ybins = ceil(max(dy)/ybinsize);
xchange = max(posx)/xbins;														% this number can be used to multiply map coordinates and find corresponding position coordinates
% initialize x,y,hd,spd matrices
for x = 1:xbins
    for y = 1:ybins        
        xmap{x,y} = [];
        ymap{x,y} = [];
        spdmap{x,y} = [];        
    end
end
poss = zeros(xbins,ybins);
% compute firing rate
frmap = zeros(xbins,ybins);
for x = 1:xbins    
    for y = 1:ybins
        %if (~isnan(poss(x,y)))        
        %     if (isempty(spkx))
        %       frmap(x,y) = 0;
        %       continue;
        %     end        
        px = x*xbinsize-(xbinsize/2);
        py = y*ybinsize-(ybinsize/2);        
        %% compute spike distances
        %disp('Computing spike distances from current point');        
        spk_ds = sqrt((px-spkx).^2+(py-spky).^2);
        %disp('Computing occupancy distances from current point');
        % compute occupancy distances
        occ_ds = sqrt((px-posx).^2+(py-posy).^2);
        bin_occ = length(find(occ_ds<min_dwell_dist));
        % do minimum dwelling filtering based on the distance from the centre of the bin
        if (bin_occ>= min_dwell)
            poss(x,y) = bin_occ;
            frmap(x,y) = sum(gaussian_kernel(spk_ds/smooth)) / (sum(gaussian_kernel(occ_ds/smooth)) * (dt_pos/1000));
            % the spike occurrance is descrete data whereas the time is a continuous data and thus has to be
            % correted with sampling rate of a continuous data.
        else
            frmap(x,y) = NaN;
            poss(x,y) = NaN;
        end
    end    
end
frmap = fliplr(frmap); frmap = rot90(frmap);
poss = fliplr(poss); poss = rot90(poss);